const { 
    SlashCommandBuilder, 
    EmbedBuilder, 
    ActionRowBuilder, 
    StringSelectMenuBuilder,
    ButtonBuilder,
    ButtonStyle 
} = require('discord.js');
const fs = require('fs');
const path = require('path');

// Chemin vers le fichier de configuration des √©v√©nements
const EVENTS_CONFIG_PATH = path.join(__dirname, '..', '..', 'events-config.json');

/**
 * ==========================================
 * COMMANDE EVENT-LIST - Liste des √©v√©nements
 * ==========================================
 * 
 * Fonction : Affiche la liste des √©v√©nements du serveur
 * 
 * Fonctionnalit√©s :
 * - Liste pagin√©e des √©v√©nements
 * - Filtrage par statut (√† venir, en cours, pass√©s)
 * - Tri par date
 * - Informations d√©taill√©es sur chaque √©v√©nement
 * - Navigation interactive avec boutons
 * 
 * Param√®tres :
 * - statut : Filtre par statut (optionnel: tous, √†-venir, pass√©s)
 * - limite : Nombre d'√©v√©nements par page (optionnel, d√©faut: 5)
 * 
 * Usage : /event-list [statut] [limite]
 */
module.exports = {
    data: new SlashCommandBuilder()
        .setName('event-list')
        .setDescription('Affiche la liste des √©v√©nements du serveur')
        .addStringOption(option =>
            option
                .setName('statut')
                .setDescription('Filtrer par statut des √©v√©nements')
                .addChoices(
                    { name: 'Tous les √©v√©nements', value: 'all' },
                    { name: '√Ä venir', value: 'upcoming' },
                    { name: 'Pass√©s', value: 'past' }
                )
                .setRequired(false)
        )
        .addIntegerOption(option =>
            option
                .setName('limite')
                .setDescription('Nombre d\'√©v√©nements par page (d√©faut: 5)')
                .setMinValue(1)
                .setMaxValue(10)
                .setRequired(false)
        ),
    emoji: 'üìã',

    async execute(interaction) {
        const statusFilter = interaction.options.getString('statut') || 'upcoming';
        const limit = interaction.options.getInteger('limite') || 5;

        await interaction.deferReply();

        try {
            // Charger la configuration des √©v√©nements
            const eventsConfig = loadEventsConfig();
            const guildEvents = eventsConfig.events[interaction.guildId] || {};

            // Convertir en array et filtrer
            let events = Object.values(guildEvents);
            
            if (events.length === 0) {
                return await interaction.editReply({
                    embeds: [createNoEventsEmbed()]
                });
            }

            // Filtrer par statut
            const now = new Date();
            events = events.filter(event => {
                const eventDate = new Date(event.dateTime);
                
                switch (statusFilter) {
                    case 'upcoming':
                        return eventDate > now;
                    case 'past':
                        return eventDate <= now;
                    default:
                        return true;
                }
            });

            if (events.length === 0) {
                return await interaction.editReply({
                    embeds: [createNoEventsEmbed(statusFilter)]
                });
            }

            // Trier par date (les plus proches en premier pour "upcoming", les plus r√©cents en premier pour "past")
            events.sort((a, b) => {
                const dateA = new Date(a.dateTime);
                const dateB = new Date(b.dateTime);
                
                if (statusFilter === 'past') {
                    return dateB - dateA; // Plus r√©cents en premier
                } else {
                    return dateA - dateB; // Plus proches en premier
                }
            });

            // Pagination
            const totalPages = Math.ceil(events.length / limit);
            let currentPage = 0;

            // Cr√©er l'embed initial
            const embed = createEventsListEmbed(events, currentPage, limit, statusFilter, totalPages);
            
            // Cr√©er les boutons de navigation si n√©cessaire
            const components = [];
            if (totalPages > 1) {
                components.push(createNavigationButtons(currentPage, totalPages));
            }

            // Ajouter le menu de s√©lection pour voir les d√©tails
            if (events.length > 0) {
                const currentPageEvents = events.slice(currentPage * limit, (currentPage + 1) * limit);
                components.push(createEventSelectMenu(currentPageEvents));
            }

            const message = await interaction.editReply({
                embeds: [embed],
                components: components
            });

            // G√©rer les interactions avec les boutons et menus
            if (components.length > 0) {
                const collector = message.createMessageComponentCollector({ 
                    time: 300000 // 5 minutes
                });

                collector.on('collect', async (componentInteraction) => {
                    if (componentInteraction.user.id !== interaction.user.id) {
                        return componentInteraction.reply({
                            content: '‚ùå Seul l\'utilisateur qui a lanc√© la commande peut naviguer.',
                            ephemeral: true
                        });
                    }

                    if (componentInteraction.isButton()) {
                        // Navigation entre les pages
                        if (componentInteraction.customId === 'events_prev') {
                            currentPage = Math.max(0, currentPage - 1);
                        } else if (componentInteraction.customId === 'events_next') {
                            currentPage = Math.min(totalPages - 1, currentPage + 1);
                        }

                        const newEmbed = createEventsListEmbed(events, currentPage, limit, statusFilter, totalPages);
                        const newComponents = [];
                        
                        if (totalPages > 1) {
                            newComponents.push(createNavigationButtons(currentPage, totalPages));
                        }
                        
                        const currentPageEvents = events.slice(currentPage * limit, (currentPage + 1) * limit);
                        newComponents.push(createEventSelectMenu(currentPageEvents));

                        await componentInteraction.update({
                            embeds: [newEmbed],
                            components: newComponents
                        });
                    } else if (componentInteraction.isStringSelectMenu()) {
                        // Afficher les d√©tails d'un √©v√©nement
                        const eventId = componentInteraction.values[0];
                        const event = events.find(e => e.id === eventId);
                        
                        if (event) {
                            const detailEmbed = createEventDetailEmbed(event, interaction.client);
                            await componentInteraction.reply({
                                embeds: [detailEmbed],
                                ephemeral: true
                            });
                        }
                    }
                });

                collector.on('end', async () => {
                    try {
                        // D√©sactiver tous les composants
                        const disabledComponents = components.map(row => {
                            const newRow = ActionRowBuilder.from(row);
                            newRow.components.forEach(component => {
                                component.setDisabled(true);
                            });
                            return newRow;
                        });

                        await interaction.editReply({
                            components: disabledComponents
                        });
                    } catch (error) {
                        // Ignorer les erreurs si le message a √©t√© supprim√©
                    }
                });
            }

        } catch (error) {
            console.error('Erreur lors de l\'affichage de la liste des √©v√©nements:', error);
            await interaction.editReply({
                content: '‚ùå Une erreur est survenue lors de l\'affichage des √©v√©nements.'
            });
        }
    }
};

// Fonctions utilitaires

function loadEventsConfig() {
    try {
        if (fs.existsSync(EVENTS_CONFIG_PATH)) {
            const data = fs.readFileSync(EVENTS_CONFIG_PATH, 'utf8');
            return JSON.parse(data);
        }
    } catch (error) {
        console.error('Erreur lors du chargement de la config √©v√©nements:', error);
    }
    
    return {
        events: {},
        reminders: {},
        settings: {
            defaultReminderTimes: [],
            maxEventsPerGuild: 50,
            maxParticipantsPerEvent: 100
        }
    };
}

function createNoEventsEmbed(statusFilter = null) {
    const embed = new EmbedBuilder()
        .setColor(0xffa500)
        .setTitle('üìã Liste des √©v√©nements')
        .setDescription('Aucun √©v√©nement trouv√©.')
        .setTimestamp();

    if (statusFilter === 'upcoming') {
        embed.setDescription('Aucun √©v√©nement √† venir trouv√©.');
    } else if (statusFilter === 'past') {
        embed.setDescription('Aucun √©v√©nement pass√© trouv√©.');
    }

    return embed;
}

function createEventsListEmbed(events, page, limit, statusFilter, totalPages) {
    const startIndex = page * limit;
    const endIndex = Math.min(startIndex + limit, events.length);
    const pageEvents = events.slice(startIndex, endIndex);

    const embed = new EmbedBuilder()
        .setColor(0x5865f2)
        .setTitle('üìã Liste des √©v√©nements')
        .setTimestamp();

    let description = '';
    switch (statusFilter) {
        case 'upcoming':
            description = 'üìÖ **√âv√©nements √† venir**\n\n';
            break;
        case 'past':
            description = 'üìú **√âv√©nements pass√©s**\n\n';
            break;
        default:
            description = 'üìã **Tous les √©v√©nements**\n\n';
    }

    pageEvents.forEach((event, index) => {
        const eventDate = new Date(event.dateTime);
        const timestamp = Math.floor(eventDate.getTime() / 1000);
        const participantCount = event.participants.attending.length;
        const isUpcoming = eventDate > new Date();
        
        const statusIcon = isUpcoming ? 'üü¢' : 'üî¥';
        
        description += `${statusIcon} **${event.title}**\n`;
        description += `üìÖ <t:${timestamp}:F> (<t:${timestamp}:R>)\n`;
        description += `üë• ${participantCount}/${event.maxParticipants} participants\n`;
        description += `üìù ${event.description.substring(0, 100)}${event.description.length > 100 ? '...' : ''}\n\n`;
    });

    embed.setDescription(description);

    if (totalPages > 1) {
        embed.setFooter({
            text: `Page ${page + 1}/${totalPages} ‚Ä¢ ${events.length} √©v√©nement(s) total`
        });
    } else {
        embed.setFooter({
            text: `${events.length} √©v√©nement(s) trouv√©(s)`
        });
    }

    return embed;
}

function createNavigationButtons(currentPage, totalPages) {
    return new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId('events_prev')
                .setLabel('‚óÄÔ∏è Pr√©c√©dent')
                .setStyle(ButtonStyle.Secondary)
                .setDisabled(currentPage === 0),
            new ButtonBuilder()
                .setCustomId('events_next')
                .setLabel('Suivant ‚ñ∂Ô∏è')
                .setStyle(ButtonStyle.Secondary)
                .setDisabled(currentPage === totalPages - 1)
        );
}

function createEventSelectMenu(events) {
    const options = events.map(event => {
        const eventDate = new Date(event.dateTime);
        const isUpcoming = eventDate > new Date();
        
        return {
            label: event.title.substring(0, 100),
            description: `${isUpcoming ? 'üü¢' : 'üî¥'} ${eventDate.toLocaleDateString('fr-FR')} - ${event.participants.attending.length} participants`,
            value: event.id
        };
    });

    return new ActionRowBuilder()
        .addComponents(
            new StringSelectMenuBuilder()
                .setCustomId('event_details_select')
                .setPlaceholder('S√©lectionner un √©v√©nement pour voir les d√©tails...')
                .addOptions(options)
        );
}

function createEventDetailEmbed(event, client) {
    const eventDate = new Date(event.dateTime);
    const timestamp = Math.floor(eventDate.getTime() / 1000);
    const isUpcoming = eventDate > new Date();
    
    const embed = new EmbedBuilder()
        .setColor(isUpcoming ? 0x00ff00 : 0xff0000)
        .setTitle(`üìÖ ${event.title}`)
        .setDescription(event.description)
        .addFields(
            { 
                name: 'üìÖ Date et heure', 
                value: `<t:${timestamp}:F>\n<t:${timestamp}:R>`, 
                inline: false 
            },
            { 
                name: 'üë• Participants confirm√©s', 
                value: `${event.participants.attending.length}/${event.maxParticipants}`, 
                inline: true 
            },
            { 
                name: '‚ùì Peut-√™tre', 
                value: `${event.participants.maybe.length}`, 
                inline: true 
            },
            { 
                name: '‚ùå Absents', 
                value: `${event.participants.notAttending.length}`, 
                inline: true 
            }
        )
        .setFooter({ 
            text: `ID: ${event.id} ‚Ä¢ Cr√©√© par ${client.users.cache.get(event.creatorId)?.tag || 'Utilisateur inconnu'}`,
            iconURL: client.user.displayAvatarURL()
        })
        .setTimestamp();

    // Afficher les participants si il y en a
    if (event.participants.attending.length > 0) {
        const attendingList = event.participants.attending
            .slice(0, 10) // Limiter √† 10 pour √©viter les embeds trop longs
            .map(userId => `<@${userId}>`)
            .join(', ');
        
        let attendingText = attendingList;
        if (event.participants.attending.length > 10) {
            attendingText += ` et ${event.participants.attending.length - 10} autre(s)...`;
        }
        
        embed.addFields({
            name: '‚úÖ Liste des participants',
            value: attendingText,
            inline: false
        });
    }

    if (event.recurrence !== 'none') {
        embed.addFields({
            name: 'üîÑ R√©currence',
            value: getRecurrenceLabel(event.recurrence),
            inline: true
        });
    }

    return embed;
}

function getRecurrenceLabel(recurrence) {
    switch (recurrence) {
        case 'weekly': return 'üîÑ Hebdomadaire';
        case 'monthly': return 'üîÑ Mensuelle';
        default: return '‚û°Ô∏è Unique';
    }
}
